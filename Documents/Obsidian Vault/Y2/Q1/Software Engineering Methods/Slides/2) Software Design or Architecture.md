- Organisation of a system: components and relations, their communication and constraints on entire system
![[Screenshot 2025-05-19 195229.png]]
- Part of "Design"
### Architectural views

| Architectural view | Use cases                                                                   | Representations                               |
| ------------------ | --------------------------------------------------------------------------- | --------------------------------------------- |
| Context view       | 1) System scope + responsibilities. 2) External services + responsibilities | Context diagram                               |
| Functional view    | Break up system into components and describe interaction between them       | Component diagram or sequence diagram         |
| Information view   | Storing, manipulating, managing of data                                     | Class diagram, ER diagram or activity diagram |

#### Software architecture (SA) representations | <mark style="background: #A33B20;">no exam Q</mark>

| Representation    | Description                                                                                                                                                                                                                                                                                                | Pros                                                                                                                                                                               | Cons                                                                                                                                          |
| ----------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| Boxes and lines   | Simply boxes and lines for separation                                                                                                                                                                                                                                                                      | 1) Easy and fast to make 2) Good discussion tools since they are intuitive to understand                                                                                           | Lack of standardisation and missing details make them 1) hard to understand. 2) Bad documentation (lack of context). 3) Inconsistent notation |
| Component diagram | ![[Screenshot 2025-05-23 191524.png]]![[Screenshot 2025-05-23 191734.png]]![[Screenshot 2025-05-23 191817.png]]1) Each component only implements single set of functionality. 2) If a component only serves one other component, merge them. 3) "Highly coupled" classes must belong in same component. 4) |                                                                                                                                                                                    |                                                                                                                                               |
| Sequence diagram  | ![[Screenshot 2025-05-23 192244.png]]![[Screenshot 2025-05-23 192706.png]]Highlights objects                                                                                                                                                                                                               | 1) Highlights interactions between actors and components. 2) Useful for requirements engineering and high level design 3) At low level, can be useful documentation for developers |                                                                                                                                               |
| Activity diagram  | Aim to highlight functions![[Screenshot 2025-05-23 192908.png]]                                                                                                                                                                                                                                            | 1) Requirement elicitation                                                                                                                                                         |                                                                                                                                               |
| C4 model          | No need to understand UML. 4 Levels: 1) Context diagram: system is central and surrounding are its users. 2) Separately runnable units that execute or store data. 3) Similar to the UML component design and intended for software architects and devs. 4) UML class diagram or ERD                       |                                                                                                                                                                                    |                                                                                                                                               |
### Architectural patterns | <mark style="background: #009FFD;">multiple exam Q</mark>
- Different patterns address different quality attributes such as performance, usability, maintainability, testability, reusability, availability, integrity (can unauthorised users change data), interoperability (well connected to other systems), scalability, robustness (ability to withstand unexpected conditions), reliability (frequency of failures), recoverability (after failure)
- **Architecture:** significant decisions that shape a system, where significant is expressed in how much time  

| Pattern                     | Description                                                                                                                                                                                                              | Pros \| <mark style="background: #FFA400;">an exam Q</mark>                                                                                                                                                                                                                                                                          | Cons \| <mark style="background: #FFA400;">an exam Q</mark>                                                                                                                                                                                                      |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Client-server               | Serves hosts, delivers and manages resources to be consumed by clients                                                                                                                                                   | 1) Scalability. 2) Reusability                                                                                                                                                                                                                                                                                                       | 1) Reliability: if server fails, all clients are affected. 2) Unpredictable: network dependency                                                                                                                                                                  |
| Layered                     | Each level can only interact with its direct neighbours                                                                                                                                                                  | 1) Testability: layers can be tested in isolation. 2) Maintainability: layer can be updated without affecting other layers. 3) Flexibility: layer can be swapped as long as new implements same interfaces                                                                                                                           | 1) More complex since abstraction requires extra interfaces and separating of levels. 2) Lower performance since there is latency when passing between layers                                                                                                    |
| Model-view-controller (MVC) | Three layered architecture, used for web development                                                                                                                                                                     | 1) Maintainability: ability to make changes to one component without affecting others. 2) Reusability: components can easily be reused. 3) Testability: able to test each layer independently                                                                                                                                        | 1) Complexity: additional code and complexity to separate layers. 2) Maintainability: easy to do things in wrong layer                                                                                                                                           |
| Pipe-filter                 | Each processing step is encapsulated in a filter, pipes connect and transport data between filters                                                                                                                       | 1) Reusability: ability to build different pipelines combining same set of filters. 2) Extensibility: easy to add new filters. 3) Testability: filters can be tested separately. 4) Concurrency: filters can start computing immediately when receiving data, potentially in parallel  (async)                                       | 1) Performance: large overhead because of data transformation. 2) Latency: not useful for interactive applications                                                                                                                                               |
| Microservices               | Represents application as a collection of loosely coupled completely different services. Useful for large an complex application with much scaling up/down and independent software teams with heterogeneous tech stacks | 1) Modularity: each microservice is easy to maintain/test and understand. 2) Scalability: microservice can be scaled independently. 3) Integration: microservices can be integrated with legacy systems (old systems) due to independence. 4) Distributed development: different teams develop different microservices independently | 1) Reliability: communication between microservices is dependent on network. 2) Deployment: services must be deployed in the correct order. 3) Security: more data in network. 4) Moving responsibilities: data migration, API changes and coordination overhead |
| Publish-subscribe           | Components that **publish** an event and **subscribers** of an event. They are connected through an event bus. They don't know of each other existence                                                                   | 1) Reusability: services can be reused to make many applications. 2) Testability: publishers and testers can be tested separately. 3) Scalability: as many publishers and subscribers. 4) Separation of responsibilities                                                                                                             | 1) Scalability: messages travel through same bus. 2) Security: message sent through same event bus. 3) Availability: did the subscriber receive data correctly?                                                                                                  |
| Event-driven                | Each event is a separate input, producers must detect, gather and transfer events. Sinks (consumers) must react to events                                                                                                | 1) Real time: useful for real time systems. 2) Loose coupling: emit and respond to events rather than directly calling each other.                                                                                                                                                                                                   | 1) Increased complexity: implement events, messages and sinks. 2) Security: event queue can be attacked. 3) Reliability: loss of events/states                                                                                                                   |

#### Cohesion | <mark style="background: #A33B20;">no exam Q</mark>
- Degree to which methods belong together
- High cohesion: independent as much as possible (all code within one place). This facilitates reuse 
![[Screenshot 2025-05-24 133949.png]]![[Screenshot 2025-05-24 133958.png]]
#### Coupling | <mark style="background: #A33B20;">no exam Q</mark>
- Degree to which classes rely on each other 
- Low coupling #loose_coupling: models implement only one task. This simplifies modifications 
- High coupling: low maintainability, because changes in one unit affects others
- Positively correlated with cohesion
### Design patterns
- Differences with architectural patterns:
	- Higher level structure, organisation of components
	- Low level score, how components are built internally
	- Although architectural patterns can influence which design patterns to use
- Contains: name, intent, target problem and solution
- Categories:
	- Behavioural: communication patterns
	- Structural: Organisation of your classes
	- Creational: creating objects in a controlled manner (based on requirements)
#### SOLID | <mark style="background: #A33B20;">no exam Q</mark>
- Single responsibility principle: only one per class
- Open close principle (OCP): open for extension, but closed for modification
- Liskov substitute principle: where a parent is required, we accept its child
- Interface segregation principle: should not be forces to depend on parts of interface it does not use. In other words, it's good to have small interfaces
- Dependency inversion principle: depend on abstractions (interfaces) not on details
#### Behavioural patterns | <mark style="background: #009FFD;">multiple exam Q</mark>

| Pattern name            | Intent                                                                                                                                                                                                                                                                                                     | Use cases                                                                                                                    | Pros \| <mark style="background: #A33B20;">no exam Q</mark>                                                                                                                                                                           | Cons \| <mark style="background: #A33B20;">no exam Q</mark>                                                                                                                       |
| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Iterator                | Traverse elements without exposing underlying representation                                                                                                                                                                                                                                               | 1) Iteration over collection is necessary. <br>2) Multiple possible iteration methods                                        | 1) Easy SRP since traversal algorithms can be in separate classes. <br>2) OCP possible for adding new collections and iterators. <br>3) Parallel iteration possible since each iterator has own state. <br>4) Able to pause iteration | 1) Overkill for apps with simple collections. 2) Less efficient than efficient for some specialised collections due to extra abstraction and already highly optimised collections |
| Strategy                | 1) Group related algorithms. <br>2) Concrete implementations in separate classes. <br>3)  Objects are interchangeable: we have algorithms doing the same in a different way. <br>4) Algorithm can be changed independent from client code: clients implement interface so we can swap underlying algorithm | 1) Similar classes implementing same interface. <br>2) Different variants of algorithm.![[Screenshot 2025-05-26 204115.png]] | 1) Flexibility to change strategy (algorithm). <br>2) Interface instead of subclassing. <br>3) Large conditionals can be simplified (delegated to strategy object)                                                                    | 1) Client might need to know about different strategies. 2) Potential communication overhead between strategy and context. 3) Increased number of objects                         |
| Chain of responsibility | A) Pass request along chain of handlers that do a part. If one handler fails/rejects, stop request. <br>B) Chain of handlers that do same. Each handler decides whether to process or pass to the next.                                                                                                    | A) Needs to handled in sequence. <br>B) Decide dynamically and automatically who processes request                           | 1) Reduced coupling: no need to know how request will handled by receiver. <br>2) Receiver/ sender don't need to know each other. <br>3) Run time changing of chain is possible                                                       | 1) No explicit receiver, which mean it request can be left unhandled                                                                                                              |
| Observer                | Define subscription mechanism to notify listeners                                                                                                                                                                                                                                                          | 1) Inform subscribers about updates. <br>2) Order in which subscribers are informed is unimportant                           | 1) OCP: can add subscriber without changing publisher code and other way around. <br>2) Establish relations at runtime                                                                                                                | 1) Subscribers are notified in random order                                                                                                                                       |
| Adapter                 | Allowing incompatible interfaces to collaborate/communicate                                                                                                                                                                                                                                                | Use existing class with incompatible interface                                                                               | 1) Client doesn't need to know implementation of original interface. <br>2) Reduces code duplication (1 adapter required)                                                                                                             | 1) Adapter highly dependent on original (sub)class. Any changes might fail adapter. 2) One additional class                                                                       |

#### Structural patterns | <mark style="background: #009FFD;">multiple exam Q</mark>

| Pattern name        | Intent                                                                                                                            | Use cases                                                                                                                                                                                                                                                                                  | Pros \| <mark style="background: #A33B20;">no exam Q</mark>                                                                                                                                                                                                   | Cons \| <mark style="background: #A33B20;">no exam Q</mark>                                         |
| ------------------- | --------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- |
| Facade              | 1) Simplified interface to library, framework                                                                                     | 1) Simple interface to complex subsystem.<br>2) Many dependencies. 3) Layer subsystems                                                                                                                                                                                                     | 1) Isolating clients from (complex) subsystems. <br>2) Supports OCP                                                                                                                                                                                           | 1) God class: one facade gets too many responsibilities                                             |
| Proxy               | 1) Substitute or placeholder for another object.<br>2) Controlling access to original object![[Screenshot 2025-05-27 224832.png]] | 1: Remote) Local object represents remote object. <br>2: Virtual) lazily load real object on demand, provide skeleton representation (lightweight placeholder) by default. <br>3: Protection) Control access to resource based on permissions. <br>4: Caching) Cache large client requests | 1) Control proxied objects without clients knowing. <br>2) Proxy can handle lifecycle of real object. <br>3) Proxy works even if real object is not available (placeholders/default). <br>4) OCP: introduce new proxies without changing real objects/clients | 1) Code might be more complex since you need new classes. <br>2) Additional latency due to wrapping |
| Decorator (wrapper) | Adding new behaviours/ responsibilities such as logging                                                                           | 1) Extra features for specific objects.<br>2) Able to add/remove features when needed.<br>3) Creating a lot of subclasses (for a lot of features) would be complicated/ messy                                                                                                              | 1) Modification at runtime.<br>2) Better solution to permutation issues.<br>3) Supports OCP                                                                                                                                                                   | 1) Can result in a lot of tiny wrapper objects if overused                                          |
| Composite           | Objects to tree structures                                                                                                        | 1) Hierarchies of objects. <br>2) Client does not need to know whether its dealing with single or composite object (since they share the same interface)                                                                                                                                   | 1) Defines class hierarchies.<br>2) Makes client simple. <br>3) New kinds of components.<br>4) OCP: add new elements without breaking existing code                                                                                                           | Difficult to provide interface for classes whose functionality differs too much                     |
#### Creational patterns | <mark style="background: #009FFD;">multiple exam Q</mark>

| Name             | Intent                                                                                                                                       | Use cases                                                                                                                                                                                                                                                                        | Pros \| <mark style="background: #A33B20;">no exam Q</mark>                                                                                                                                                                                            | Cons \| <mark style="background: #A33B20;">no exam Q</mark>                                                                                                                 |
| ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Factory method   | 1) Interface for subclasses to create objects of superclass (override).<br>2) Subclasses can alter type of objects that will be created      | 1) Class can't anticipate objects it must create. <br>2) Class wants its subclasses to specify the objects it creates. <br>3) Classes delegate responsibility to one of its subclasses                                                                                           | 1) Avoid coupling between creator and concrete results. <br>2) SRP: move creation code into a separate place in separate place in program. <br>3) OCP: add n=new types without breaking existing code                                                  | Complex due to subclasses that must implement pattern                                                                                                                       |
| Abstract factory | 1) Produce families of related objects without specifying their concrete class<br><br>* near same as factory but then with multiple products | 1) System independent from how products are created. <br>2) System configured of one of multiple families of products. <br>3) Family of related product objects designed to work together and constraint must be enforced. <br>4) Don't want to reveal implementation of library | 1) Factory produces compatible products. <br>2) Avoids tight coupling between concrete products and client code. <br>3) SRP: extract product creation code to one place. <br>4) OCP: introduce new variants of products without breaking existing code | 1) Complexity: requires lot's of interfaces and classes                                                                                                                     |
| Builder          | 1) Construct complex objects step by step. <br>2) Different types of representations of objects with same construction code                  | 1) Algorithm for creating complex object independent of parts that make object. <br>2) Construction must allow different representations of object being constructed                                                                                                             | 1) Step by step.<br>2) Reuse same construction for various representations of products. <br>3) SRP: isolate complex construction from business logic                                                                                                   | 1) Complexity increases since builder requires new classes                                                                                                                  |
| Singleton        | 1) Class only has one instance. <br>2) Global access to that class, but no class can modify directly                                         | 1) Static is not possible (static can't use interfaces or inherit). <br>2) Must only be one instance of a class                                                                                                                                                                  | 1) Single instance. <br>2) Globally accessible. <br>3) Single instantiation.                                                                                                                                                                           | 1) Can mask bad design. <br>2) Special treatment for multithreaded environment. <br>3) Difficult to test clients of singletons. <br>4) Cannot create subclass of singletons |
##### UML | <mark style="background: #009FFD;">multiple exam Q</mark>
#UML 
*** 
### Todo
- [ ] Clear UML manual and make sure everything required to know is in there
- [x] Rewriting architectural patterns to be clearer
- [x] Revisit the slides
- [x] Bullet points in tables should have line breaks: shift + enter